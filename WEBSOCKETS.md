**WEBSOCKETS.md**

# WebSockets (Comunicação em Tempo Real)

**Objetivo:** Introduzir comunicação em tempo real na aplicação para suportar funcionalidades como **chat**, **notificações push**, **atualizações ao vivo** nos dados e controle de concorrência em edições (por exemplo, impedir que dois usuários editem o mesmo registro simultaneamente). A meta é utilizar uma solução **self-hosted** (local, sem serviços de terceiros) integrada ao Laravel. Optaremos por usar o novo servidor first-party **Laravel Reverb** (WebSockets) – uma vez que ele permite rodar um servidor WebSocket dentro da própria aplicação Laravel de forma gratuita – em vez de serviços como Pusher ou Ably. Isso será configurado dentro do nosso ambiente Docker, de modo que o servidor WebSocket rode junto com a aplicação (podendo escalar no futuro se necessário). Lembraremos de integrar o sistema de WebSockets tanto com o contexto central quanto com os tenants, garantindo que eventos de um tenant não vazem para outro e que apenas usuários autenticados recebam mensagens relevantes.

## Configuração do Servidor WebSocket Local

* [ ] **Escolher e instalar solução WebSocket:** Adicionar o suporte ao WebSocket no backend Laravel. A opção preferencial é usar o **Laravel Reverb** (pacote oficial para WebSockets no Laravel 12). Rodar o comando php artisan install:broadcasting, que instala e configura o Reverb com defaults. Isso criará o arquivo de config config/reverb.php e ajustará o .env com variáveis como REVERB\_APP\_ID, REVERB\_APP\_KEY, REVERB\_APP\_SECRET. Essas credenciais serão usadas para autenticar os clients (similar ao modelo do Pusher). Confirmar que no .env também definiremos BROADCAST\_DRIVER=reverb para que o Laravel use o Reverb como driver de broadcast.

* [ ] **Allowed origins e portas:** Configurar no config/reverb.php (ou .env) os **origins permitidos** para conexões WebSocket. Incluir nossos domínios locais, por exemplo hero.localhost e subdomínios relevantes (\*.hero.localhost), para que o handshake do WebSocket seja aceito. Verificar também as portas: por padrão o Reverb sobe em 0.0.0.0:8080. Podemos manter 8080 ou alterar conforme conflito. No .env, podemos definir REVERB\_SERVER\_HOST=0.0.0.0 (todas interfaces) e REVERB\_SERVER\_PORT=6001 (porta comum para WS) ou 8080 mesmo. Garantir que essas portas não conflitam com outros serviços e que o Nginx proxy ou expõe se necessário.

* [ ] **Executar o servidor no Docker:** Integrar a execução do servidor WebSocket ao ambiente Docker. Temos duas abordagens:

* **Mesma máquina (processo separado):** Executar php artisan reverb:start junto com o container da aplicação. Podemos configurar o entrypoint do PHP-FPM para iniciar o websockets em background ou usar um gerenciador (Supervisor) dentro do container para rodar ambos processos (PHP-FPM e Reverb).

* **Container dedicado:** Alternativamente, criar um novo serviço no docker-compose para WebSockets usando a mesma imagem Laravel, mas com comando de inicialização diferente (ex.: php artisan reverb:start \--host=0.0.0.0 \--port=8080). Isso isolaria o processo WS. Em ambos os casos, assegurar que a porta escolhida (8080 ou 6001, etc.) esteja exposta no docker-compose.yml e que o Nginx esteja configurado para fazer passthrough de upgrade de conexão WebSocket se necessário (ou o front-end conecte diretamente na porta do serviço). Exemplo: permitir conexões ws/wss em wss://hero.localhost:8080 ou via um subdomínio (ex.: wss://ws.hero.localhost) apontado para o mesmo serviço.

* [ ] **Integrar com front-end (Laravel Echo):** No projeto front (Vue/Vite), configurar o **Laravel Echo** (ou outro cliente WS) para conectar ao nosso servidor WebSocket local. Usar as credenciais definidas (APP\_KEY, etc.) no Echo. Por exemplo, ajustar para broadcaster pusher, chave igual ao REVERB\_APP\_KEY, wsHost apontando para hero.localhost (ou ws.hero.localhost se usado), wsPort e wssPort conforme configurado (8080, etc.), forceTLS se usando wss, e disableStats true. Testar a conexão do front: ao carregar a aplicação, deve conseguir estabelecer websocket (ver console do browser para confirmação do handshake upgrade HTTP 101).

## Autenticação e Autorização no WebSocket

* [ ] **Conexão somente autenticada:** Garantir que somente usuários logados consigam se conectar e ouvir eventos pertinentes. Com Reverb/Pusher, normalmente usamos o endpoint de autenticação de canal fornecido pelo Laravel. Precisamos ajustar a rota /broadcasting/auth para aceitar nosso esquema de autenticação via token. Isso envolve configurar no BroadcastServiceProvider as rotas de broadcast com middleware auth:api. Exemplo: Broadcast::routes(\['middleware' \=\> \['auth:api'\]\]);. Assim, quando o Echo (no front) tentar se inscrever em um canal privado ou de presença, ele enviará o token no header Authorization, e o Laravel validará o usuário via Passport. Verificar que o guard utilizado seja compatível (podemos forçar o guard api para broadcast no config broadcasting.php).

* [ ] **Autorização de canais privados:** Definir as regras de acesso para canais privados/presença. No routes/channels.php (ou similar), registrar closures ou Channel classes para autorizar a entrada em determinados canais. Por exemplo, se tivermos um canal privado tenant.{$tenantId}.notifications, podemos verificar no closure se Auth::user()-\>tenant\_id \== $tenantId para permitir a assinatura. Configurar lógica semelhante para canais de chat ou outros: assegurar que o usuário só entra em canais referentes ao seu tenant ou às entidades que ele tem acesso. Para canais de **presença**, o procedimento é similar (e o Laravel cuida de enviar a lista de participantes).

* [ ] **Isolamento por tenant nos eventos:** Ao definir nomes de canais para broadcast, incluir sempre o identificador do tenant quando o evento for específico de um tenant. Exemplo: usar um prefixo com o slug ou id do tenant nos canais: tenant-{id}-algo. Isso evita qualquer confusão e facilita a lógica de autorização acima. Além disso, no backend, ao disparar eventos de broadcast, certifique-se de estar “dentro” do contexto do tenant correto (por exemplo, se um evento ocorre durante uma request no tenant, o próprio middleware tenancy já ajusta o ambiente; mas se disparar um evento global, pode-se usar Tenancy::getTenant() para pegar o id e incluir manualmente no nome do canal).

* [ ] **Proteção de dados sensíveis:** Revisar se algum evento transmitido carrega dados que precisam ser filtrados por usuário. Por exemplo, notificações pessoais devem ir para canais privados do usuário (ex: private-user.{id}) ao invés de canais de tenant visíveis a todos daquele tenant. Definir essa granularidade: eventos **globais do tenant** (visíveis a todos usuários do tenant, ex: “novo item adicionado” que todos podem ver) vs eventos **privados do usuário** (ex: “sua tarefa foi atualizada”) que vão apenas para o interessado. Implementar canais de acordo e suas autorizações.

## Estrutura de Canais e Casos de Uso

* [ ] **Canal de Chat em tempo real:** Decidir a estrutura para chat. Poderia haver um canal por sala de chat ou um canal global por tenant para chat geral. Exemplo simples: um canal público chat.general.{tenantId} onde todos os usuários daquele tenant que estiverem na página de chat se conectam. Sempre incluir {tenantId} para isolamento. Quando um usuário enviar uma mensagem, o backend emite um evento (e.g. MessageSent) nesse canal com o conteúdo, e todos conectados recebem instantaneamente. Implementar evento e teste básico para verificar funcionamento.

* [ ] **Notificações em tempo real:** Integrar o sistema de notificações do Laravel para usar broadcast. Podemos marcar certas notificações (via Notification Laravel) para broadcast, o que emite um evento automaticamente para um canal like App.Models.User.{id}. Alternativamente, criar eventos customizados. Planejar o envio de notificações globais do tenant (por exemplo, “um novo usuário entrou no seu tenant”) via um canal tenant-{id}-notifications que todos daquele tenant ouçam. E notificações específicas de usuário via canal privado do usuário (por exemplo, private-user-{id}-notifications). Implementar um caso para testar: por exemplo, quando um registro X é atualizado, enviar notificação broadcast para administradores do tenant.

* [ ] **Presença e lock de edição (BREAD):** Para resolver o caso de **concorrência na edição de registros** (ex.: impedir dois usuários de editar simultaneamente o mesmo item), utilizar **canais de presença**. Estratégia:

* Cada recurso editável (por ex, um registro de livro com id 42\) terá um canal de presença único, ex: presence-editing.book.42 ou similar.

* Quando um usuário abrir a tela de edição, o front deve se inscrever nesse canal de presença. Laravel Echo enviará a autenticação, e o backend deve autorizar apenas se o usuário tem acesso ao recurso (e pertence ao tenant correto).

* A partir daí, o servidor WebSocket mantém uma lista dos participantes nesse canal (quem está “editando” o item 42). Podemos configurar no front para escutar eventos de join/leave ou verificar a quantidade de membros. Se um segundo usuário tentar entrar enquanto já houver alguém no canal, significa que o recurso está em edição por outro – podemos então notificar o segundo usuário que o registro está bloqueado no momento (ou simplesmente recusar a assinatura).

* Podemos também fazer o servidor emitir um evento para o primeiro usuário avisando que alguém tentou acessar, dependendo da lógica desejada.

* Em resumo, usar a funcionalidade de **presence channels** do Echo/Reverb para controlar locks de edição. Haverá implementação tanto do lado front (inscrição e reação) quanto do lado back (autorizar e talvez emitir eventos de “lock adquirido/liberado”). Este recurso deve ser testado com dois usuários em navegadores diferentes para garantir que o segundo é devidamente bloqueado/avisado.

* [ ] **Eventos de exemplo e validação:** Após configurar tudo, realizar um teste completo: por exemplo, criar um evento Laravel (e.g., BookCreated evento broadcast) que é disparado quando um novo livro é adicionado no sistema. Fazer com que ele seja broadcast no canal do tenant (ex: tenant-{id}-books). No front-end, inscrever-se nesse canal e logar as mensagens. Então, ao criar um livro via API, verificar que o evento é recebido em tempo real no front. Ajustar quaisquer detalhes se o evento não for recebido (pode ser necessário configurar queue driver como redis ou sync para broadcasting; em desenvolvimento talvez usar sync para simplificar).

* [ ] **Escalabilidade e monitoramento (futuro):** Anotar que em produção, se precisarmos escalar para múltiplas instâncias de WebSocket, poderemos usar o Redis para compartilhar estado de clientes entre nós ou usar sticky sessions. Por agora, em dev, um único servidor Reverb lida com tudo. Habilitar logs de debug do Reverb (php artisan reverb:start \--debug) ao testar localmente para inspecionar o fluxo de mensagens e garantir que está funcionando. Podemos também considerar integrar o Laravel **Pulse** (monitoramento) com Reverb no futuro para acompanhar número de conexões, etc., mas não é prioritário neste momento.

## Deliverables

* [ ] **Servidor WebSocket operante no ambiente dev:** O Laravel Reverb está instalado e rodando dentro do Docker. Verificado que a porta de WebSocket está acessível e que a conexão WebSocket se estabelece (código de status 101 Switching Protocols ao conectar do front-end). Nenhum serviço terceiro (como Pusher) é necessário – a solução é totalmente self-hosted.

* [ ] **Comunicação em tempo real funcional:** Um evento simples disparado no backend resulta em mensagem recebida no frontend instantaneamente. Por exemplo, ao criar um objeto X no tenant, os clientes conectados naquele tenant recebem a atualização via WebSocket sem precisar fazer polling.

* [ ] **Autenticação e segurança nos canais:** Somente usuários autenticados conseguem receber eventos privados. Tentativas de conexões não autorizadas (ex: token inválido ou usuário tentando ouvir canal de outro tenant) são rejeitadas pelo servidor (verificado nos logs do Reverb e no comportamento do front). A lógica de autorização de canais garante isolamento entre tenants e respeita as permissões definidas (ex.: um usuário de tenant A não consegue subscrever canais de tenant B; e em canais privados de usuário, apenas aquele usuário recebe).

* [ ] **Chat e notificações testados:** Implementada uma estrutura básica de chat (ex.: canal de chat geral por tenant) e de notificações. Testado que usuários conseguem trocar mensagens em tempo real dentro do mesmo tenant. Notificações importantes (simulando, por exemplo, “novo usuário registrado”) são enviadas via broadcast e aparecem para os usuários destinatários imediatamente.

* [ ] **Mecanismo de lock de edição validado:** Configurado o canal de presença para edição de recursos e testado o cenário: um usuário abre edição de um item, e quando um segundo usuário tenta editar simultaneamente, o sistema o detecta (por exemplo, o segundo não entra no canal ou recebe informação de que já está em uso). Dessa forma, garantimos a exclusividade na edição.

* [ ] **Documentação e uso:** (Este documento serve como guia de implementação.) Adicionalmente, qualquer configuração necessária no front-end (Echo, etc.) foi documentada e aplicada. Em produção, planeja-se usar wss (WebSocket seguro) talvez em um subdomínio próprio, mas a arquitetura local já replica isso usando TLS via hero.localhost. A solução de WebSockets integrada traz capacidade de chat, notificações e colaboração em tempo real ao projeto, atendendo aos casos de uso propostos sem dependências externas.
