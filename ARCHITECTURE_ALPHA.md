# Arquitetura Proposta do Projeto **Hero**

## Visão Geral

O projeto **Hero** é um monorepo com backend Laravel (pasta **/api**) e frontend SPA em Vue 3/Vuetify (pasta **/app**). Ele suporta **multi-tenancy** (vários clientes isolados) e está sendo aprimorado para fornecer uma infraestrutura robusta (*“nível industrial”*) alinhada às práticas modernas. A proposta a seguir consolida melhorias discutidas nas análises anteriores e nos chats, visando corrigir erros do projeto atual, eliminar configurações manuais desnecessárias e implementar todos os recursos planejados (autenticação OAuth2, internacionalização, geração de código BREAD, documentação, etc.).

Em resumo, **os principais objetivos da nova arquitetura são**:

* **Configuração Zero-Config e Containerização Unificada:** Padronizar variáveis e defaults no Docker Compose de modo que um desenvolvedor possa executar docker compose up sem passos manuais extras. Remover o arquivo .env na raiz e definir valores padrão diretamente no docker-compose.yml (domínio, portas, credenciais), integrando geração automática de certificados SSL de desenvolvimento e garantindo que *primeira execução* execute instalações iniciais (Composer, NPM) de forma transparente.

* **Estrutura de Código Modular e Manutenível:** Organizar o backend Laravel em camadas claras (p. ex. **Domain**, **Application**, **Infrastructure**), com **Contracts** e **Services** bem definidos, seguindo padrões *Domain-driven* quando aplicável. No frontend, migrar de classes estáticas para **composables** reativos e stores (Pinia), conforme o roadmap, promovendo reuso e simplicidade. Ambos os lados utilizarão **DTOs e contratos de dados compartilhados** (pasta /shared) para manter o alinhamento nas interfaces de comunicação.

* **Multi-Tenancy Completo e Isolado:** Consolidar a implementação de multi-tenancy usando **stancl/tenancy**. Cada tenant terá seu **próprio banco de dados** MariaDB, com criação e migração automatizada via comandos Artisan. Requisições serão separadas por subdomínio (ex.: cliente.hero.localhost), carregando apenas dados do tenant correspondente – rotas de tenant definidas em routes/tenant.php estarão protegidas para não serem acessíveis pelo domínio central[\[1\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/.roadmaps/api/03-roadmap-multitenancy.md#L10-L18)[\[2\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/.roadmaps/api/03-roadmap-multitenancy.md#L12-L20). Haverá comandos utilitários para criação, seed e remoção segura de tenants (ex.: tenants:create, tenants:delete), garantindo que ao excluir um tenant seus dados (BD, tokens OAuth) sejam removidos ou invalidados corretamente.

* **Autenticação OAuth2 com Controle de Permissões:** Implementar **Laravel Passport** para autenticação via tokens JWT (OAuth2) em vez de sessões. O fluxo principal será *Password Grant* (login com e-mail/senha retornando access/refresh token) e refresh token transparente. Endpoints dedicados (ex.: POST /api/v1/auth/login, /refresh, /logout, /me) encapsularão as rotas OAuth do Passport[\[3\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L2-L10). Além disso, integrar o pacote **spatie/laravel-permission** para atribuir *roles* e *permissões* por tenant[\[4\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/BLUEPRINT.md#L14-L19). Cada token OAuth incluirá *scopes* correspondentes às permissões do usuário (e.g. scope users.read ligado à permissão “ver usuários”)[\[5\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L8-L16). Rotas serão protegidas por middleware de autenticação (auth:api) e autorização (can: ou middleware do Spatie) conforme necessário. Haverá um usuário administrador padrão (por tenant ou global) para facilitar os testes iniciais[\[6\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L8-L11).

* **API Padronizada e Internacionalizada:** Todas as respostas JSON seguirão um **formato unificado** de sucesso/erro. Será criada uma estrutura global de resposta (ex.: trait ou helper **ApiResponse**) para retornar objetos JSON consistentes. Conforme definido nos contratos do front[\[7\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L2-L5), respostas de sucesso terão forma { ok: true, status: 200, data: {…} } e erros { ok: false, status: 400, error: { code: 'ERROR\_CODE', message: 'Mensagem descritiva', …} }. O handler de exceções do Laravel será personalizado para formatar erros (404, 500, validação) nesse padrão, utilizando códigos de erro humanizados (conforme tabela definida em **docs/errors.md** do hero-alpha[\[7\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L2-L5)). Além disso, a API suportará **internacionalização (i18n)**, respondendo em inglês ou português conforme o header Accept-Language ou parâmetro. Um middleware LocaleFromRequest definirá App::setLocale('pt\_BR' | 'en') antes de cada request[\[8\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/.roadmaps/api/04-roadmap-i18n-api.md#L6-L14). Mensagens de validação e erros utilizarão arquivos de tradução em resources/lang/ para ambos idiomas[\[9\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/.roadmaps/api/04-roadmap-i18n-api.md#L10-L18), permitindo ao front-end e usuários receberem feedback no idioma escolhido.

* **Integração Frontend-Backend via Contratos Compartilhados:** Será mantida a pasta **/shared** com interfaces TypeScript que definem os DTOs (ex.: User, Book, LoginRequest, ApiError, etc.)[\[10\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/app/ROADMAP.md#L69-L77)[\[11\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/app/ROADMAP.md#L71-L79). O backend seguirá esses contratos ao estruturar modelos, *resources* e validações. Por exemplo, a entidade User no Laravel fornecerá campos exatamente como a interface User do front (campos em **camelCase**, datas em ISO 8601, etc.), provavelmente usando API Resources para transformar os modelos[\[12\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L2-L5). Assim, reduzimos discrepâncias e evitamos mapeamentos manuais no front. Essa sincronia será *disciplinada manualmente* inicialmente – desenvolvedores deverão atualizar ambos os lados ao alterar um contrato – mas futuramente avaliaremos ferramentas para gerar automaticamente tipos TypeScript a partir de Resources Laravel (ou vice-versa).

* **Geração de Código e Módulos BREAD:** Para acelerar a implementação de funcionalidades padrão (cadastro de usuários, livros, etc.), adotaremos um esquema BREAD (*Browse, Read, Edit, Add, Delete*) padronizado. O hero-alpha já inclui *stubs* e esboço de um comando make:bread[\[13\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L2-L5). Pretendemos implementar um comando Artisan **make:bread {Model}** que **gerará automaticamente** as classes básicas de um novo módulo: *migration*, *model*, *factory*, *seeder*, *controller API*, *Form Request* de validação, *Resource* (API Resource) e rotas correspondentes[\[14\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/.roadmaps/api/06-roadmap-bread-e-geracao.md#L6-L14). Esse comando terá opções para casos específicos (por ex.: \--tenant para criar migration em namespace de tenant, \--softDeletes, \--uuid para usar UUIDs como chave primária)[\[15\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/.roadmaps/api/06-roadmap-bread-e-geracao.md#L10-L18). A ideia é que, ao rodar make:bread Book, tenhamos o CRUD de **Book** pronto ou quase pronto, seguindo os padrões de resposta e segurança definidos. Testes básicos também poderão ser gerados (usando Pest) cobrindo endpoints principais[\[15\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/.roadmaps/api/06-roadmap-bread-e-geracao.md#L10-L18). Essa abordagem padronizada evita código repetitivo e mantém consistência entre módulos.

* **Automação, Qualidade e Desempenho:** Serão implementados comandos Artisan utilitários para manutenção, como limpeza de caches/config, reset de ambiente (ex.: recriar bancos de todos tenants em dev), geração de certificados, etc., consolidando scripts shell existentes em comandos Laravel quando fizer sentido[\[16\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L2-L5). Para melhorar a qualidade, configuraremos ferramentas de análise estática (PHPStan via Larastan) e formatação (Laravel Pint) integradas ao fluxo de CI. Também adicionaremos **testes automatizados** (Pest PHP) cobrindo funcionalidades críticas: autenticação (login/refresh/logout), multi-tenancy (isolamento de dados por tenant), principais casos de uso do domínio (CRUDs) e componentes do frontend (testes unitários de composables, e2e com Cypress) – com meta inicial de cobertura \~70%. No aspecto de **desempenho**, como estaremos usando Redis para cache/fila isolados por tenant, avaliaremos ativar o Laravel Horizon para monitorar filas se necessário no futuro[\[17\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L2-L5). Para *real-time*, manteremos o servidor Node WebSocket de exemplo por ora (rodando em paralelo ao front)[\[18\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L2-L4). Esse servidor (definido em app/src/node/server.ts) escuta eventos e permite notificar clientes via WebSockets; planeja-se integrá-lo com o Laravel via Redis Pub/Sub (ex.: Laravel emite eventos em um canal Redis ao criar uma notificação, o Node repassa aos clientes conectados)[\[19\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/BLUEPRINT.md#L1-L9). Futuramente, podemos considerar substituir por **Laravel WebSockets** (biblioteca *BeyondCode*) para unificar em PHP, mas isso adiciona complexidade e será decidido mais adiante[\[18\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L2-L4).

* **Documentação e Versionamento da API:** Focaremos em fornecer documentação abrangente tanto para desenvolvedores quanto para usuários finais. Será criada a pasta **/docs** no repositório, contendo guias em Markdown (por exemplo: **docs/auth.md**, **docs/errors.md**, **docs/websockets.md**) aproveitando materiais já presentes no hero-alpha. Haverá um **README** de API explicando como autenticar, como usar os principais endpoints, códigos de erro e exemplos de requisição/resposta[\[20\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L13-L15). Além disso, vamos introduzir documentação de referência via **Swagger/OpenAPI**: definiremos uma spec OpenAPI 3.0 cobrindo todos os endpoints da versão v1, incluindo modelos de request/response. Essa spec poderá ser servida através de uma interface Swagger UI acessível (protegida ou apenas em dev). Prevemos também lidar com **versionamento da API**: todas as rotas atuais estarão sob prefixo /api/v1[\[21\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/BLUEPRINT.md#L14-L21), e já deixaremos preparado o esqueleto para /api/v2 (mesmo que vazio)[\[22\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/.roadmaps/api/01-roadmap-arquitetura-e-versionamento.md#L13-L19). No futuro, caso lançada a v2, manteremos a v1 operando em paralelo por um período (e documentaremos sinais de depreciação). A documentação deverá permitir alternar entre versões e idiomas – possivelmente fornecendo a spec em inglês e português, ou pelo menos descrição de campos em ambos idiomas. Isso atenderá à solicitação de internacionalização não só nas mensagens da API mas também na documentação de uso.

## Ambiente de Desenvolvimento e Docker

**Docker Compose Unificado:** A arquitetura usará um único arquivo **docker-compose.yml** na raiz para orquestrar todos os serviços: **app (PHP/Laravel)**, **queue** (worker de filas Laravel), **frontend** (Node/Vite), **nginx**, **db** (MariaDB), **redis** e **mailhog** (para captura de e-mails). Vamos eliminar dependências de variáveis de ambiente externas, definindo no próprio compose valores padrão para domínio, portas e senhas. Por exemplo, usar o domínio padrão hero.localhost e portas 80/443 (HTTP/HTTPS) para Nginx, porta 3000 para frontend (servidor Vite), 1025/8025 para Mailhog etc.[\[23\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/docker-compose.yml#L44-L52)[\[24\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/docker-compose.yml#L96-L101). Assim, não será necessário criar ou editar arquivos .env manualmente para rodar em dev – o ambiente “sobe” com valores padrão que funcionam em qualquer máquina.

**Remoção do .env Raiz:** O arquivo .env na raiz do repositório será removido. Nele, o projeto mantinha variáveis como APP\_DOMAIN, NGINX\_HTTP\_PORT e duplicatas de URLs (API\_URL, etc.) que agora serão desnecessárias[\[25\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L13-L21). O domínio base e portas serão resolvidos pelo Docker Compose e injetados no container do Nginx e demais conforme preciso. Cada subprojeto continuará a ter seu .env próprio: **/api/.env** (para config Laravel, por exemplo keys do Passport, credenciais de API externas se houver) e **/app/.env** (config do front, ex. VITE\_API\_URL). Porém, mesmo esses podem ser preenchidos automaticamente com defaults na primeira execução (copiados de arquivos exemplo), para diminuir setup manual. **Resultado:** a configuração do ambiente local será praticamente *zero-config*, bastando ter Docker instalado.

**Geração Automática de Certificados SSL:** No projeto atual, o container Nginx depende de um certificado autoassinado (hero.localhost.crt) para subir em HTTPS. Implementaremos a geração automática desse certificado de desenvolvimento na *primeira execução*. Em vez de exigir que o desenvolvedor rode scripts manualmente, vamos integrar isso no processo Docker. Uma estratégia é adicionar um script de *entrypoint* no container Nginx que verifica se os arquivos **.crt** e **.key** existem em docker/nginx/ssl; se não, gera-os via **openssl** ou usando **mkcert** (se disponível)[\[26\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/.dev-helpers/create-dev-certs.sh#L17-L25)[\[27\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/.dev-helpers/create-dev-certs.sh#L26-L34). O script .dev-helpers/create-dev-certs.sh do Hero atual, que já faz exatamente isso (gerando certificado wildcard para \*.hero.localhost com SAN incluindo api.hero.localhost)[\[28\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/.dev-helpers/create-dev-certs.sh#L8-L16)[\[27\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/.dev-helpers/create-dev-certs.sh#L26-L34), será aproveitado dentro do container. Dessa forma, ao subir os serviços pela primeira vez, o certificado será criado e então o Nginx iniciará normalmente em HTTPS[\[29\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/.dev-helpers/create-dev-certs.sh#L53-L59). Isso resolve o bug atual onde o Nginx falha por falta do certificado. Os caminhos do cert/key permanecerão padronizados (/etc/nginx/ssl/hero.localhost.crt), já referenciados no template de configuração Nginx[\[30\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L23-L26).

**Templates Nginx Unificados:** Simplificaremos a configuração Nginx mantendo um único template de servidor que escuta nas portas 80 e 443\. No Hero original havia múltiplos templates (hero.conf.template, hero-ssl.conf.template), mas usaremos apenas um, combinando lógica de HTTP/HTTPS. Esse template será preenchido via envsubst no entrypoint do Nginx com as variáveis de domínio, porta do frontend e paths de certificado[\[31\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/docker-compose.yml#L50-L58). Ele definirá hosts para hero.localhost (central) e wildcard subdomínio \*.hero.localhost (tenants) apontando para o PHP-FPM (Laravel) em /api e para o Vite dev server em / ou uma subrota dedicada. Ou seja, requisições ao domínio raiz hero.localhost servirão a aplicação frontend (proxy para o container **frontend** na porta 3000), enquanto requisições para paths /api ou para subdomínios qualquer.hero.localhost serão roteadas para o backend Laravel[\[18\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L2-L4). Essa separação permite, por exemplo, que o SPA em hero.localhost faça chamadas à API em api.hero.localhost sem problemas de CORS (pois podemos tratar como mesmo domínio base com subdomínio). Também configuraremos no Nginx cabeçalhos de segurança básicos (como HSTS, X-Content-Type-Options, etc.) e suporte a WebSocket (upgrade de conexão na rota /socket redirecionada para o servidor Node, caso seja utilizado). *Obs.:* O DNS .localhost permite que qualquer subdomínio resolva para 127.0.0.1 automaticamente, o que facilita os testes de multi-tenancy sem configurações extras.

**Imagens e Build dos Contêineres:** Para o backend Laravel, utilizaremos a imagem oficial **php:fpm-alpine** (PHP 8.3) como base, instalando as extensões necessárias (pdo\_mysql, mbstring, zip, gd, pcntl, redis, etc.). Conforme preferências, evitaremos arquivos Dockerfile separados; sempre que possível, faremos as instalações no próprio processo de *build* do Docker Compose ou em scripts de inicialização. Por exemplo, podemos aproveitar o container **composer** oficial para instalar dependências do PHP sem precisar de Dockerfile custom – um serviço one-off que monta o volume do código e roda composer install. Entretanto, para agilizar, podemos manter uma etapa de build do PHP com multi-stage (como feito no hero-alpha) caso necessário para incluir extensões nativas[\[32\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/api/Dockerfile#L10-L18)[\[33\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/api/Dockerfile#L12-L16). O importante é centralizar a definição no docker-compose.yml – este file orquestrará o build da imagem Laravel e do Node.

O container **frontend** usará a imagem **node:20-alpine** e rodará automaticamente npm install seguido de npm run dev ao iniciar[\[34\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/docker-compose.yml#L105-L113). Faremos semelhante no container **app (PHP)**: um *entrypoint script* verificará se a pasta vendor/ está vazia e, na primeira execução, rodará composer install (pode-se baixar o Composer PHAR dinamicamente ou usar composer:2 via Docker). Assim, quando alguém clonar o repositório e subir os containers, o backend será instalado automaticamente no primeiro run. Em execuções subsequentes, com vendor/ já preenchido e migrations rodadas, esses passos serão ignorados, acelerando o start. Também podemos aproveitar esse entrypoint para rodar migrações iniciais (por exemplo, php artisan tenants:migrate \--seed para configurar o banco central e algum tenant default) – mas isso será avaliado com cuidado para não surpreender em dev.

**Banco de Dados e Variáveis:** Unificaremos o nome do host do banco para **db** (nome do serviço Docker do MariaDB). O Hero original tinha uma incongruência usando DB\_HOST=mariadb no .env da API, enquanto no docker-compose o serviço se chamava db[\[35\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L2-L5). Iremos corrigir definindo DB\_HOST=db por padrão (ajustando .env.example da API). As credenciais padrão serão padronizadas: usuário hero e senha hero (ou outra senha forte padrão) – atualmente no hero a senha default era “hero” e no hero-alpha “password”[\[36\]](https://github.com/tiagohaasouza/hero/blob/b24a5efe76e936f4a29c6e8edd153c8e15efb676/ARCHITECTURE.md#L16-L19). Podemos unificar em **“password”** para manter consistência com exemplos, ou outra senha, mas documentaremos isso claramente. De todo modo, essas credenciais sendo apenas de dev, não representam risco. O volume de dados do MariaDB será persistente (volume nomeado db\_data) para evitar perda de dados entre levantes de contêiner.

**Serviços Auxiliares:** Incluiremos um container **Redis** (v7) para cache e filas, e **Mailhog** para interceptar e visualizar e-mails enviados (porta 8025 UI). Ambos já estavam presentes no docker-compose do hero-alpha[\[37\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/docker-compose.yml#L85-L93)[\[24\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/docker-compose.yml#L96-L101). O Laravel já está configurado para usar Redis para cache e queue, e no contexto multi-tenant o pacote Tenancy automaticamente configura prefixos de cache e separação de filas por tenant[\[38\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/BLUEPRINT.md#L22-L25)[\[39\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/BLUEPRINT.md#L12-L20). Manteremos isso – ex.: cada tenant terá suas keys de cache com prefixo único.

**Ordem de Inicialização:** Faremos com que **app (Laravel)** aguarde o MariaDB e Redis estarem prontos antes de subir (usando depends\_on: condition: service\_healthy com healthchecks)[\[40\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/docker-compose.yml#L6-L14)[\[41\]](https://github.com/tiagohaasouza/hero-alpha/blob/85e28bcc6b12e118f300d17cfad3d2c37f2760ab/docker-compose.yml#L66-L74). Similarmente, o **queue** worker só inicia após o app estar rodando. O Nginx por sua vez dependerá do app e do frontend. Assim garantimos que, quando o Nginx estiver aceitando conexões, o PHP e o Vite já estejam prontos para responder.

**Diferença de Primeira Execução:** Conforme mencionado, alguns passos ocorrerão apenas no primeiro up: instalação do Composer, Node e geração de cert. Para detectar “primeira execução”, podemos adotar estratégias simples, como criar um arquivo marcador (p. ex. .first\_run\_done) em volumes do container após instalar, ou checar a existência da pasta vendor e node\_modules. Os entrypoints/scripts usarão essas condições. Na prática, isso significa que o desenvolvedor verá logs de instalação apenas no início; nas próximas vezes, subir/descer containers será rápido.

**Perfil de Produção:** Embora o foco seja o ambiente de desenvolvimento, já deixaremos preparado um perfil para eventual deploy. Por exemplo, no docker-compose poderemos ter ajustes para produção (disable Mailhog, usar imagem construída do front em vez de Vite dev server, etc.). Isso pode ser controlado via arquivos de override ou variáveis de ambiente (NODE\_ENV, etc.). Também integraremos passos de otimização no build (ex.: rodar php artisan config:cache no build de prod). Esses detalhes ficarão registrados na documentação de deploy.

## Roadmaps de Implementação

A seguir detalhamos um **roadmap** em etapas para implementar a nova arquitetura e funcionalidades. As tarefas estão divididas por contexto (backend **api** e frontend **app**), com caixas de seleção para acompanhamento do progresso. Recomenda-se seguir nessa ordem, iniciando pela configuração do ambiente Docker (etapa 1), pois ela desbloqueia um ambiente estável para desenvolver e testar as demais melhorias.

## Roadmaps

Os roadmaps foram movidos para a pasta `.roadmaps`. Consulte os arquivos em `.roadmaps/api` e `.roadmaps/app` para detalhes.
